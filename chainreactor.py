import sys, os, subprocess, platform, ast, re
import streamlit as st

# --- BOOTSTRAP: AUTO-RUN ---
def launch():
    if not os.environ.get("STREAMLIT_RUNNING"):
        os.environ["STREAMLIT_RUNNING"] = "true"
        try:
            from streamlit.web import cli as stcli
            sys.argv = ["streamlit", "run", __file__, "--server.headless", "false"]
            sys.exit(stcli.main())
        except Exception:
            subprocess.check_call([sys.executable, "-m", "pip", "-q", "install", "streamlit"])

if __name__ == "__main__":
    launch()

# --- STYLING ---
st.set_page_config(page_title="Chain Reactor", layout="wide")
st.markdown("""
    <style>
    .stApp { background-color: #000; color: #0f0; }
    .stTextInput input { background-color: #0a0a0a; color: #0f0; border: 1px solid #333; font-family: monospace; }
    textarea { background-color: #050505 !important; color: #0f0 !important; font-family: 'Courier New', monospace !important; border: 1px solid #222 !important; }
    .order-tag { color: #000; background-color: #0f0; padding: 2px 8px; border-radius: 10px; font-weight: bold; font-size: 0.8rem; }
    .stCheckbox label { color: #0f0 !important; }
    </style>
    """, unsafe_allow_html=True)

st.title("üîó CHAIN REACTOR")

if 'steps' not in st.session_state: st.session_state.steps = ["ls", "pwd"]
if 'selected_order' not in st.session_state: st.session_state.selected_order = []

# --- 1. THE COMMAND BUILDER & SEQUENCER ---
st.write("### üèóÔ∏è Build & Sequence")
for i in range(len(st.session_state.steps)):
    cols = st.columns([0.05, 0.75, 0.1, 0.1])
    
    # Selection logic
    is_selected = cols[0].checkbox("", key=f"sel_{i}")
    
    # Manage ordering
    if is_selected:
        if i not in st.session_state.selected_order:
            st.session_state.selected_order.append(i)
        order_idx = st.session_state.selected_order.index(i) + 1
        cols[0].markdown(f"<span class='order-tag'>o{order_idx}</span>", unsafe_allow_html=True)
    else:
        if i in st.session_state.selected_order:
            st.session_state.selected_order.remove(i)

    # Command Input
    st.session_state.steps[i] = cols[1].text_input(f"S{i}", value=st.session_state.steps[i], key=f"in_{i}", label_visibility="collapsed")
    
    if cols[2].button("üß©", key=f"p_{i}"):
        st.session_state.steps[i] += " {row}"
        st.rerun()
    if cols[3].button("‚ùå", key=f"d_{i}"):
        st.session_state.steps.pop(i)
        st.rerun()

# --- 2. ACTION CONTROLS ---
c1, c2, c3, c4 = st.columns([0.15, 0.15, 0.35, 0.35])
if c1.button("Ôºã ADD STEP"): st.session_state.steps.append(""); st.rerun()
if c2.button("üóëÔ∏è RESET"): 
    st.session_state.steps = [""]
    st.session_state.selected_order = []
    st.rerun()

# --- 3. SCRIPT GENERATOR ---
if c3.button("üìú GENERATE PYTHON SCRIPT"):
    if not st.session_state.selected_order:
        st.warning("Select at least one command first.")
    else:
        ordered_cmds = [st.session_state.steps[idx] for idx in st.session_state.selected_order]
        
        script_content = f"""
import subprocess, os

def run_automation():
    # Sequence generated by Chain Reactor
    commands = {ordered_cmds}
    working_dir = os.getcwd()

    for cmd in commands:
        print(f"Executing: {{cmd}}")
        res = subprocess.run(cmd, shell=True, capture_output=True, text=True, cwd=working_dir)
        print(res.stdout if res.returncode == 0 else res.stderr)
        
        if cmd.startswith("cd "):
            path = cmd.replace("cd ", "").strip()
            working_dir = os.path.abspath(os.path.join(working_dir, path))

if __name__ == "__main__":
    run_automation()
"""
        st.markdown("### üõ†Ô∏è Generated Script")
        st.text_area("Copy this Python code:", value=script_content.strip(), height=300)

# --- 4. EXECUTION ENGINE ---
if c4.button("üöÄ RUN SELECTED", type="primary"):
    working_dir = os.getcwd()
    last_output = []
    
    for idx in st.session_state.selected_order:
        cmd = st.session_state.steps[idx]
        st.write(f"‚öôÔ∏è **o{st.session_state.selected_order.index(idx)+1}: {cmd}**")
        
        # Persistent Execution Logic (as developed previously)
        res = subprocess.run(cmd, shell=True, capture_output=True, text=True, cwd=working_dir)
        out = res.stdout if res.returncode == 0 else res.stderr
        st.text_area("Output", value=out, height=150, key=f"run_out_{idx}")
        
        if cmd.startswith("cd "):
            working_dir = os.path.abspath(os.path.join(working_dir, cmd.replace("cd ", "").strip()))
